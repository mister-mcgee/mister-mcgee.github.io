---
tags: ["csf", "binary", "programming"]
---


What is a Computer, Binary, Bits and Bytes, Programming Languages


### What is Binary?

The word *binary* comes from the latin *bini-* (meaning *two*), and *-ary* (meaning *part of*). The word *binary* is often used to describe something with two parts, but in the language of mathematics and computer science it often refers to the base-2 number system where all numerals are expressed using the digits zero `0` and one `1`.

It can be intimidating to approach new mathematical concepts, but before your eyes glaze over I encourage you to persevere. Understanding binary is fundamentally important in understanding modern computers.

While base-2 may seem foreign, you are likely accustomed to using the base-10 numeric system known as *decimal*. Thinking about how we interpret decimal numerals can give us some insight regarding how we interpret binary numerals.

In base-10 each numeral is represented using *ten* digits, from zero '0' to nine '9'. The digit and its *place* within a numeral inform the value of each digit. Consider the base-10 numeral `345` where we describe the digit five `5` as being in the *ones place*, the digit four `4` in the *tens place*, and the digit three `3` in the *hundreds place*. Automatically, we know this means there are five *ones* (`5`), four *tens* (`40`), and three *hundreds* (`300`). Another way to visualize this relationships is to write the numeral in its *expanded form* -

```
345 = 300 + 40 + 5
    = (3 * 100 ) + (4 * 10  ) + (5 * 1   )
    = (3 * 10^2) + (4 * 10^1) + (5 * 10^0)
```

When looking at a decimal numeral's *expanded form* it is easy to see that each *place* represents a power of ten `10`. We can use the same expanded form to describe binary numerals. Consider the binary numeral `1010`. We would say that the digit zero `0` is in the *ones place*, the digit one `1` is in the *twos place*, the digit zero `0` is in the *fours place* and the digit one `1` is in the *eights place*. We can write the numeral in its *expanded form* as -

```
(1 * 2^3) + (0 * 2^2) + (1 * 2^1) + (0 * 2^0) =
( 1 * 8 ) + ( 0 * 4 ) + ( 1 * 2 ) + ( 0 * 1 ) =
8 + 0 + 2 + 0 = 10
```

In the same way that each *place* in a decimal numeral represents a power of ten, each *place* in a binary numeral represents a power of two. This pattern is true for any base *n*, where each *place* of a *base-n* numeral is a power of *n*. While it's outside the scope of this lesson, programmers often use several different bases to represent numerals in code. Most programming languages support the use of *binary* (base-2), *octal* (base-8), *decimal* (base-10), and *hexadecimal* (base-16) numerals.

### Why use Binary?

A computer is a "thinking" machine, meaning that it is capable of "choosing" an outcome based on some input or prior state. This is primarily accomplished through the use of *switches* and variable voltages. In a modern electronic computer, binary signals are transmitted by encoding `zeroes` as "low" voltage and ones `1` as "high" voltage, but this wasn't always the case. Early *electromechanical* computers used many different, more exotic techniques to encode and transmit data. Some notable examples include trinary and the mixed bi-quinary encoding.

To be clear, binary encoding has always been appealing to engineers and computer scientists alike because of its simplicity. Intuitively, the circuitry required to distinguish between *two* voltages is relatively simple when compared to the circuitry required to distinguish between *many* voltages; however, early electronic switches had significant space and power requirements. This often meant fewer, more complicated switches were more economical.

Many of these early electromechanical machines relied on *vacuum tubes* (or *thermionic valves* for our friends across the pond). These were simple electronic switches that could control the flow of electricity *electronically*. This was an important innovation in the development of computing because previous electromechanical switches often relied on the movement of a physical component to control the flow of electricity. These electromechanical switches were often slower than their *thermionic* counterparts and prone to mechanical failure.

Vacuum tube technology had many shortcomings of its own, primarily the space and power requirements of each component. The name *<u>therm</u>-ionic* comes from the fact that the negative electrode inside must first be brought up to temperature in order to function. This was the primary contributor to the significant power requirements of these devices.

It wasn't until the invention of the *transistor* that binary encoding became the dominant method of storing and transmitting data. The transistor revolutionized computing by dramatically reducing the size and power footprint of computing devices, completely eliminating the need for vacuum tubes and other electromechanical components. This allowed for the creation of smaller, more efficient, and more powerful computers.
